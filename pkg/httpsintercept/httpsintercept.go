package httpsintercept

import (
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rand"
	"crypto/rsa"
	"crypto/tls"
	"crypto/x509"
	"crypto/x509/pkix"
	"encoding/pem"
	"errors"
	"log"
	"math/big"
	"net"
	"strings"
	"sync"
	"time"
)

type Intercept struct {
	publicKey    *x509.Certificate // Public key of the Intermediate CA or Root CA used to sign the fake certificates
	privateKey   *rsa.PrivateKey   // Private key of the Intermediate CA or Root CA used to sign the fake certificates
	privateKeyEC *ecdsa.PrivateKey // Private key of the Intermediate CA or Root CA used to sign the fake certificates
	rootCA       *x509.Certificate // Root CA certificate to complete the chain of trust
	domain       string            // Primary domain (and port) of the HTTP server. Used to serve AIA certificates.

	// certificateStorage contains all issued certificates including rw lock
	certStorage certificateStorage
}

// certificateStorage contains all issued certificates including rw lock
type certificateStorage struct {
	mutex        sync.RWMutex
	Certificates map[string]IssuedCertificate
}

// IssuedCertificate contains a single issued certificate
type IssuedCertificate struct {
	Certificate         *tls.Certificate `json:"certificate"`
	Expires             time.Time        `json:"expires"`
	OperationInProgress bool             `json:"operation_in_progress"`
}

var (
	ErrInvalidPublicKey  = errors.New("invalid public key")
	ErrInvalidPrivateKey = errors.New("invalid private key")
)

// New creates a new Intercept object with the provided public key, private key,
// and root CA public key. The public key and private key are used to sign the
// fake certificates generated by the MITM proxy. The root CA public key is used
// to complete the chain of trust when generating the fake certificates.
func New(newPublicKey, newPrivateKey []byte, password string, newRootCAPublicKey []byte) (*Intercept, error) {
	// Load the public key of the Intermediate CA or Root CA
	pubPem, _ := pem.Decode(newPublicKey)
	if pubPem == nil {
		return nil, ErrInvalidPublicKey
	}

	// Load the public key of the Intermediate CA or Root CA
	parsedPublicKey, err := x509.ParseCertificate(pubPem.Bytes)
	if err != nil {
		return nil, err
	}

	// Load the private key of the Intermediate CA or Root CA
	privPem, _ := pem.Decode(newPrivateKey)
	if privPem == nil {
		return nil, ErrInvalidPrivateKey
	}
	if x509.IsEncryptedPEMBlock(privPem) || privPem.Type == "ENCRYPTED PRIVATE KEY" {
		privPem.Bytes, _ = x509.DecryptPEMBlock(privPem, []byte(password))
	}

	privateKey, err := x509.ParsePKCS8PrivateKey(privPem.Bytes)
	// May be a PKCS1 private key
	if err != nil {
		if privateKey, err = x509.ParsePKCS1PrivateKey(privPem.Bytes); err != nil {
			// May be an ECDSA private key
			if privateKey, err = x509.ParseECPrivateKey(privPem.Bytes); err != nil {
				return nil, err
			}
		}
	}

	// Load the Root CA certificate
	var rootCA *x509.Certificate
	if newRootCAPublicKey != nil {
		rootPem, _ := pem.Decode(newRootCAPublicKey)
		rootCA, err = x509.ParseCertificate(rootPem.Bytes)
		if err != nil {
			return nil, err
		}
	}

	// If private key is an ECDSA key, parse into different variable
	if _, ok := privateKey.(*ecdsa.PrivateKey); ok {
		return &Intercept{
			publicKey:    parsedPublicKey,
			privateKeyEC: privateKey.(*ecdsa.PrivateKey),
			rootCA:       rootCA,

			certStorage: certificateStorage{
				Certificates: make(map[string]IssuedCertificate),
			},
		}, nil
	}

	if _, ok := privateKey.(*rsa.PrivateKey); !ok {
		return nil, ErrInvalidPrivateKey
	}

	rsaPrivateKey := privateKey.(*rsa.PrivateKey)

	return &Intercept{
		publicKey:  parsedPublicKey,
		privateKey: rsaPrivateKey,
		rootCA:     rootCA,

		certStorage: certificateStorage{
			Certificates: make(map[string]IssuedCertificate),
		},
	}, nil
}

// SetDomain sets the primary domain (and port) of the HTTP server. This domain
// is used to serve the AIA certificates.
func (c *Intercept) SetDomain(domain string) {
	c.domain = domain
}

// GetCertificate fetches a certificate from certificateStorage or issues a new one
func (c *Intercept) GetCertificate(domain string) *tls.Certificate {
	c.certStorage.mutex.RLock()
	val, ok := c.certStorage.Certificates[domain]
	c.certStorage.mutex.RUnlock()

	if !ok {
		if err := c.CreateCertificate(domain); err != nil {
			log.Printf("Failed to create certificate for %s: %v", domain, err)
		}

		c.certStorage.mutex.RLock()
		val, ok = c.certStorage.Certificates[domain]
		c.certStorage.mutex.RUnlock()
		if !ok {
			log.Printf("Failed to get certificate for %s", domain)
			return nil
		}
	}

	return val.Certificate
}

// StartOperation sets OperationInProgress to true to prevent issuance flooding
func (c *certificateStorage) StartOperation(domain string) {
	c.mutex.Lock()
	defer c.mutex.Unlock()
	c.Certificates[domain] = IssuedCertificate{
		OperationInProgress: true,
	}
}

// EndOperation sets OperationInProgress to false to allow new issuance for existing domain
func (c *certificateStorage) EndOperation(domain string) {
	c.mutex.Lock()
	defer c.mutex.Unlock()
	c.Certificates[domain] = IssuedCertificate{
		OperationInProgress: false,
	}
}

// IsInOperation returns if an operation for a given domain is active
func (c *certificateStorage) IsInOperation(domain string) bool {
	c.mutex.RLock()
	defer c.mutex.RUnlock()
	return c.Certificates[domain].OperationInProgress
}

// CreateCertificate creates a new certificate for a given domain
func (c *Intercept) CreateCertificate(domain string) error {
	if c.certStorage.IsInOperation(domain) {
		log.Printf("Operation for %s is already in progress, waiting for completion", domain)
		time.Sleep(time.Second)
		return c.CreateCertificate(domain)
	}
	c.certStorage.StartOperation(domain)

	certificateCer, _ := c.generateProxyCertificate(domain)

	c.certStorage.mutex.Lock()
	defer c.certStorage.mutex.Unlock()
	c.certStorage.Certificates[domain] = IssuedCertificate{
		Certificate:         certificateCer,
		Expires:             certificateCer.Leaf.NotAfter,
		OperationInProgress: false,
	}
	log.Printf("Generated new certificate for %s", domain)

	return nil
}

// GC checks if a issued certificate is valid for less than 2 minutes and deletes it
func (c *Intercept) GC() {
	c.certStorage.mutex.Lock()
	defer c.certStorage.mutex.Unlock()

	// Count the number of certificates before
	records := len(c.certStorage.Certificates)

	// Check if any certificate is valid for less than 2 minutes. If so, delete
	// it from the certificate storage.
	for domain, cert := range c.certStorage.Certificates {
		if time.Until(cert.Expires).Minutes() <= 2 {
			log.Println("CertificateStorage GC: Removing", domain, "from generated certificates")
			delete(c.certStorage.Certificates, domain)
		}
	}

	// DEBUG: Log the number of certificates removed
	log.Printf("CertificateStorage GC: Removed %d certificates from %d", records-len(c.certStorage.Certificates), records)
}

// returnCert is called by TLS server including provided SNI name
func (c *Intercept) ReturnCert(helloInfo *tls.ClientHelloInfo) (*tls.Certificate, error) {
	domain := strings.ToLower(helloInfo.ServerName)
	// If no SNI domain was found, use certificate for dns
	if domain == "" {
		domain = "httpsintercept"
	}
	log.Println("New incoming request for", domain)

	certFromStore := c.GetCertificate(domain)
	return certFromStore, nil
}

// generateProxyCertificate generates a new certificate which is signed by an intermediate CA
func (c *Intercept) generateProxyCertificate(requestedHostname string) (*tls.Certificate, error) {
	// generate a unique and random serial number for certificate
	serialNumberLimit := new(big.Int).Lsh(big.NewInt(1), 128)
	serialNumber, err := rand.Int(rand.Reader, serialNumberLimit)
	if err != nil {
		log.Fatalf("Failed to generate serial number: %v", err)
	}

	// prefill certificate with generic fields
	template := x509.Certificate{
		SerialNumber: serialNumber,
		Subject: pkix.Name{
			CommonName: requestedHostname,
		},

		// certificate is valid from now -1 hour until now in 24 hours
		NotBefore: time.Now().Add(time.Hour * -1),
		NotAfter:  time.Now().Add(time.Hour * 24),

		KeyUsage:              x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature,
		ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth, x509.ExtKeyUsageClientAuth},
		BasicConstraintsValid: true,
	}

	// If domain is set, add AIA extension to certificate to allow clients to
	// download the intermediate certificate if missing.
	if c.domain != "" {
		template.IssuingCertificateURL = []string{"http://" + c.domain + "/intercept.crt"}
	}

	// Also if domain is set, add main domain to SANs
	if c.domain != "" {
		// Given domain might be a IPv4 or IPv6 address. If this is the case, it needs to be added to IPAddresses
		if addr := net.ParseIP(c.domain); addr != nil {
			template.IPAddresses = append(template.IPAddresses, addr)
		} else {
			// Domain might be a domain:port combination or just a domain. Split domain and port
			domainParts := strings.Split(c.domain, ":")
			if len(domainParts) > 1 {
				template.DNSNames = append(template.DNSNames, domainParts[0])
			} else {
				template.DNSNames = append(template.DNSNames, c.domain)
			}
		}
	}

	// detect if given domain is an IP address
	// IPs do have a custom field for validation
	// if it is not an IP address, assume it is a regular domain name
	if addr := net.ParseIP(requestedHostname); addr != nil {
		template.IPAddresses = append(template.IPAddresses, addr)
	} else {
		template.DNSNames = append(template.DNSNames, requestedHostname)
	}

	// generate new private key
	key, err := genKeyPair()
	if err != nil {
		return nil, err
	}

	// Load correct private key
	var privKey interface{}
	if c.privateKeyEC != nil {
		privKey = c.privateKeyEC
	} else {
		privKey = c.privateKey
	}

	// issue certificate
	x, err := x509.CreateCertificate(rand.Reader, &template, c.publicKey, key.Public(), privKey)
	if err != nil {
		return nil, err
	}

	// create certificate container including new certificate, private key and chain
	cert := new(tls.Certificate)
	cert.Certificate = append(cert.Certificate, x)
	cert.PrivateKey = key
	cert.Leaf, _ = x509.ParseCertificate(x)

	// add intermediate certificate to chain
	cert.Certificate = append(cert.Certificate, c.publicKey.Raw)
	cert.Leaf.Issuer = c.publicKey.Subject

	// add root certificate to chain
	if c.rootCA != nil {
		cert.Certificate = append(cert.Certificate, c.rootCA.Raw)
	}

	return cert, nil
}

// genKeyPair generates a new private key
func genKeyPair() (*ecdsa.PrivateKey, error) {
	return ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
}
