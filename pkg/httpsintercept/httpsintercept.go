package httpsintercept

import (
	"crypto"
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rand"
	"crypto/rsa"
	"crypto/tls"
	"crypto/x509"
	"crypto/x509/pkix"
	"encoding/pem"
	"errors"
	"log"
	"math/big"
	"net"
	"os"
	"slices"
	"strings"
	"sync"
	"time"
)

type Intercept struct {
	publicKey    *x509.Certificate // Public key of the Intermediate CA or Root CA used to sign the fake certificates
	privateKey   *rsa.PrivateKey   // Private key of the Intermediate CA or Root CA used to sign the fake certificates
	privateKeyEC *ecdsa.PrivateKey // Private key of the Intermediate CA or Root CA used to sign the fake certificates
	rootCA       *x509.Certificate // Root CA certificate to complete the chain of trust
	domain       string            // Primary domain of the HTTPS server. Used for SAN
	aiaAddress   string            // Authority Information Access (AIA) URL for the issued certificates
	crlAddress   string            // CRL Distribution Point URL for the issued certificates

	// certificateStorage contains all issued certificates including rw lock
	certStorage certificateStorage
}

// certificateStorage contains all issued certificates including rw lock
type certificateStorage struct {
	mutex        sync.RWMutex
	Certificates map[string]IssuedCertificate
}

// IssuedCertificate contains a single issued certificate
type IssuedCertificate struct {
	Certificate         *tls.Certificate `json:"certificate"`
	Expires             time.Time        `json:"expires"`
	OperationInProgress bool             `json:"operation_in_progress"`
}

var (
	ErrInvalidPublicKey  = errors.New("invalid public key")
	ErrInvalidPrivateKey = errors.New("invalid private key")
)

// New creates a new Intercept object with the provided public key, private key,
// and root CA public key. The public key and private key are used to sign the
// fake certificates generated by the MITM proxy. The root CA public key is used
// to complete the chain of trust when generating the fake certificates.
func New(newPublicKey, newPrivateKey []byte, password string, newRootCAPublicKey []byte) (*Intercept, error) {
	parsedPublicKey, err := parsePublicKey(newPublicKey)
	if err != nil {
		return nil, err
	}

	privateKey, err := parsePrivateKey(newPrivateKey, password)
	if err != nil {
		return nil, err
	}

	rootCA, err := parseRootCA(newRootCAPublicKey)
	if err != nil {
		return nil, err
	}

	return createIntercept(parsedPublicKey, privateKey, rootCA)
}

// parsePublicKey parses the provided public key and returns an x509.Certificate
func parsePublicKey(newPublicKey []byte) (*x509.Certificate, error) {
	pubPem, _ := pem.Decode(newPublicKey)
	if pubPem == nil {
		return nil, ErrInvalidPublicKey
	}

	return x509.ParseCertificate(pubPem.Bytes)
}

// parsePrivateKey parses the provided private key and returns an interface{}
func parsePrivateKey(newPrivateKey []byte, password string) (interface{}, error) {
	// Decode the private key from PEM format
	privPem, _ := pem.Decode(newPrivateKey)
	if privPem == nil {
		return nil, ErrInvalidPrivateKey
	}

	// Decrypt the private key if it is encrypted
	if x509.IsEncryptedPEMBlock(privPem) {
		if privPem.Type == "ENCRYPTED PRIVATE KEY" || privPem.Type == "EC PRIVATE KEY" {
			var err error
			if privPem.Bytes, err = x509.DecryptPEMBlock(privPem, []byte(password)); err != nil {
				return nil, err
			}
		} else {
			return nil, ErrInvalidPrivateKey
		}
	}

	// Parse the private key using the PKCS#8, PKCS#1, and ECDSA formats
	privateKey, err := x509.ParsePKCS8PrivateKey(privPem.Bytes)
	if err != nil {
		privateKey, err = x509.ParsePKCS1PrivateKey(privPem.Bytes)
		if err != nil {
			privateKey, err = x509.ParseECPrivateKey(privPem.Bytes)
			if err != nil {
				return nil, err
			}
		}
	}

	return privateKey, nil
}

// parseRootCA parses the provided root CA public key and returns an x509.Certificate
func parseRootCA(newRootCAPublicKey []byte) (*x509.Certificate, error) {
	if newRootCAPublicKey == nil {
		return nil, nil
	}

	rootPem, _ := pem.Decode(newRootCAPublicKey)
	if rootPem == nil {
		return nil, ErrInvalidPublicKey
	}

	return x509.ParseCertificate(rootPem.Bytes)
}

// createIntercept creates a new Intercept object with the provided public key,
// private key, and root CA public key
func createIntercept(parsedPublicKey *x509.Certificate, privateKey interface{}, rootCA *x509.Certificate) (*Intercept, error) {
	intercept := &Intercept{
		publicKey: parsedPublicKey,
		rootCA:    rootCA,
		certStorage: certificateStorage{
			Certificates: make(map[string]IssuedCertificate),
		},
	}

	switch key := privateKey.(type) {
	case *ecdsa.PrivateKey:
		intercept.privateKeyEC = key
	case *rsa.PrivateKey:
		intercept.privateKey = key
	default:
		return nil, errors.New("invalid private key type")
	}

	return intercept, nil
}

// SetAIAAddress sets the Authority Information Access (AIA) URL for the issued
// certificates.
func (c *Intercept) SetAIAAddress(aiaAddress string) {
	c.aiaAddress = aiaAddress
}

// SetDomain sets the primary domain of the HTTPS server. This domain is used
// for SAN.
func (c *Intercept) SetDomain(domain string) {
	c.domain = domain
}

// SetCRLAddress sets the CRL Distribution Point URL for the issued
// certificates.
func (c *Intercept) SetCRLAddress(crlAddress string) {
	c.crlAddress = crlAddress
}

// GetCertificate fetches a certificate from certificateStorage or issues a new one
func (c *Intercept) GetCertificate(domain string) *tls.Certificate {
	c.certStorage.mutex.RLock()
	val, ok := c.certStorage.Certificates[domain]
	c.certStorage.mutex.RUnlock()

	if !ok {
		if err := c.CreateCertificate(domain); err != nil {
			log.Printf("Failed to create certificate for %s: %v", domain, err)
		}

		c.certStorage.mutex.RLock()
		val, ok = c.certStorage.Certificates[domain]
		c.certStorage.mutex.RUnlock()
		if !ok {
			log.Printf("Failed to get certificate for %s", domain)
			return nil
		}
	}

	return val.Certificate
}

// StartOperation sets OperationInProgress to true to prevent issuance flooding
func (c *certificateStorage) StartOperation(domain string) {
	c.mutex.Lock()
	defer c.mutex.Unlock()
	cert := c.Certificates[domain]
	cert.OperationInProgress = true
	c.Certificates[domain] = cert
}

// EndOperation sets OperationInProgress to false to allow new issuance for existing domain
func (c *certificateStorage) EndOperation(domain string) {
	c.mutex.Lock()
	defer c.mutex.Unlock()
	cert := c.Certificates[domain]
	cert.OperationInProgress = false
	c.Certificates[domain] = cert
}

// IsInOperation returns if an operation for a given domain is active
func (c *certificateStorage) IsInOperation(domain string) bool {
	c.mutex.RLock()
	defer c.mutex.RUnlock()
	return c.Certificates[domain].OperationInProgress
}

// CreateCertificate creates a new certificate for a given domain
func (c *Intercept) CreateCertificate(domain string) error {
	if c.certStorage.IsInOperation(domain) {
		log.Printf("Operation for %s is already in progress, waiting for completion", domain)
		time.Sleep(time.Second)
		return c.CreateCertificate(domain)
	}
	c.certStorage.StartOperation(domain)

	certificateCer, err := c.generateProxyCertificate(domain)
	if err != nil {
		c.certStorage.EndOperation(domain)
		return err
	}

	c.certStorage.mutex.Lock()
	c.certStorage.Certificates[domain] = IssuedCertificate{
		Certificate:         certificateCer,
		Expires:             certificateCer.Leaf.NotAfter,
		OperationInProgress: false,
	}
	c.certStorage.mutex.Unlock()
	log.Printf("Generated new certificate for %s", domain)

	return nil
}

// GC removes expired and nearly expired certificates from the storage
func (c *Intercept) GC() {
	c.certStorage.mutex.Lock()
	defer c.certStorage.mutex.Unlock()

	var toDelete []string
	for domain, cert := range c.certStorage.Certificates {
		if time.Until(cert.Expires) <= 2*time.Minute {
			toDelete = append(toDelete, domain)
		}
	}
	for _, domain := range toDelete {
		log.Println("CertificateStorage GC: Removing", domain, "from generated certificates")
		delete(c.certStorage.Certificates, domain)
	}
	log.Printf("CertificateStorage GC: Removed %d certificates, %d remain", len(toDelete), len(c.certStorage.Certificates))
}

// returnCert is called by TLS server including provided SNI name
func (c *Intercept) ReturnCert(helloInfo *tls.ClientHelloInfo) (*tls.Certificate, error) {
	domain := strings.ToLower(helloInfo.ServerName)
	// If no SNI domain was found, use certificate for dns
	if domain == "" {
		domain = c.domain
	}
	log.Println("New incoming request for", domain)

	certFromStore := c.GetCertificate(domain)
	return certFromStore, nil
}

// generateProxyCertificate generates a new certificate which is signed by an intermediate CA
func (c *Intercept) generateProxyCertificate(requestedHostname string) (*tls.Certificate, error) {
	serialNumberLimit := new(big.Int).Lsh(big.NewInt(1), 128)
	serialNumber, err := rand.Int(rand.Reader, serialNumberLimit)
	if err != nil {
		log.Printf("Failed to generate serial number: %v", err)
		return nil, err
	}

	template := x509.Certificate{
		SerialNumber: serialNumber,
		Subject: pkix.Name{
			CommonName: requestedHostname,
		},
		NotBefore: time.Now().Add(-1 * time.Hour),
		NotAfter:  time.Now().Add(24 * time.Hour),
		KeyUsage:  x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature,
		ExtKeyUsage: []x509.ExtKeyUsage{
			x509.ExtKeyUsageServerAuth,
			x509.ExtKeyUsageClientAuth,
		},
		BasicConstraintsValid: true,
	}

	if c.aiaAddress != "" {
		template.IssuingCertificateURL = []string{c.aiaAddress}
	}
	if c.crlAddress != "" {
		template.CRLDistributionPoints = []string{c.crlAddress}
	}

	// Add SANs: requestedHostname (IP or DNS)
	if ip := net.ParseIP(requestedHostname); ip != nil {
		template.IPAddresses = append(template.IPAddresses, ip)
	} else {
		template.DNSNames = append(template.DNSNames, requestedHostname)
	}

	// Add c.domain to SANs, if gesetzt und noch nicht enthalten
	if c.domain != "" {
		domain := c.domain
		if strings.Contains(domain, ":") {
			domain = strings.Split(domain, ":")[0]
		}
		if ip := net.ParseIP(domain); ip != nil {
			found := false
			for _, existing := range template.IPAddresses {
				if existing.Equal(ip) {
					found = true
					break
				}
			}
			if !found {
				template.IPAddresses = append(template.IPAddresses, ip)
			}
		} else {
			if !slices.Contains(template.DNSNames, domain) {
				template.DNSNames = append(template.DNSNames, domain)
			}
		}
	}

	key, err := genKeyPair()
	if err != nil {
		return nil, err
	}

	var privKey any
	if c.privateKeyEC != nil {
		privKey = c.privateKeyEC
	} else {
		privKey = c.privateKey
	}

	x, err := x509.CreateCertificate(rand.Reader, &template, c.publicKey, key.Public(), privKey)
	if err != nil {
		return nil, err
	}

	cert := &tls.Certificate{
		Certificate: [][]byte{x},
		PrivateKey:  key,
	}
	cert.Leaf, _ = x509.ParseCertificate(x)

	// add intermediate certificate to chain
	cert.Certificate = append(cert.Certificate, c.publicKey.Raw)
	cert.Leaf.Issuer = c.publicKey.Subject

	if c.rootCA != nil {
		cert.Certificate = append(cert.Certificate, c.rootCA.Raw)
	}

	return cert, nil
}

// genKeyPair generates a new private key
func genKeyPair() (*ecdsa.PrivateKey, error) {
	return ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
}

// GenerateCRL generates a Certificate Revocation List (CRL) for the issued
// certificates. This list will always be empty.
func (c *Intercept) GenerateCRL(crlAddress, path string) error {
	// Prepare empty revoked certificates list
	revoked := []pkix.RevokedCertificate{}

	now := time.Now()
	nextUpdate := now.AddDate(0, 0, 8)

	var priv crypto.Signer
	if c.privateKeyEC != nil {
		priv = c.privateKeyEC
	} else {
		priv = c.privateKey
	}

	crlBytes, err := x509.CreateRevocationList(rand.Reader, &x509.RevocationList{
		SignatureAlgorithm:  0,
		Issuer:              c.publicKey.Subject,
		ThisUpdate:          now,
		NextUpdate:          nextUpdate,
		RevokedCertificates: revoked,
		Number:              big.NewInt(now.Unix()),
	}, c.publicKey, priv)
	if err != nil {
		return err
	}

	file, err := os.Create(path)
	if err != nil {
		return err
	}
	defer file.Close()

	// Store the file in DER format
	if _, err := file.Write(crlBytes); err != nil {
		return err
	}

	return nil
}
