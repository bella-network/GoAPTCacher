package httpsintercept

import (
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rand"
	"crypto/rsa"
	"crypto/tls"
	"crypto/x509"
	"crypto/x509/pkix"
	"encoding/pem"
	"errors"
	"log"
	"math/big"
	"net"
	"os"
	"strings"
	"sync"
	"time"
)

type Intercept struct {
	publicKey    *x509.Certificate // Public key of the Intermediate CA or Root CA used to sign the fake certificates
	privateKey   *rsa.PrivateKey   // Private key of the Intermediate CA or Root CA used to sign the fake certificates
	privateKeyEC *ecdsa.PrivateKey // Private key of the Intermediate CA or Root CA used to sign the fake certificates
	rootCA       *x509.Certificate // Root CA certificate to complete the chain of trust
	domain       string            // Primary domain of the HTTPS server. Used for SAN
	aiaAddress   string            // Authority Information Access (AIA) URL for the issued certificates

	// certificateStorage contains all issued certificates including rw lock
	certStorage certificateStorage
}

// certificateStorage contains all issued certificates including rw lock
type certificateStorage struct {
	mutex        sync.RWMutex
	Certificates map[string]IssuedCertificate
}

// IssuedCertificate contains a single issued certificate
type IssuedCertificate struct {
	Certificate         *tls.Certificate `json:"certificate"`
	Expires             time.Time        `json:"expires"`
	OperationInProgress bool             `json:"operation_in_progress"`
}

var (
	ErrInvalidPublicKey  = errors.New("invalid public key")
	ErrInvalidPrivateKey = errors.New("invalid private key")
)

// New creates a new Intercept object with the provided public key, private key,
// and root CA public key. The public key and private key are used to sign the
// fake certificates generated by the MITM proxy. The root CA public key is used
// to complete the chain of trust when generating the fake certificates.
func New(newPublicKey, newPrivateKey []byte, password string, newRootCAPublicKey []byte) (*Intercept, error) {
	parsedPublicKey, err := parsePublicKey(newPublicKey)
	if err != nil {
		return nil, err
	}

	privateKey, err := parsePrivateKey(newPrivateKey, password)
	if err != nil {
		return nil, err
	}

	rootCA, err := parseRootCA(newRootCAPublicKey)
	if err != nil {
		return nil, err
	}

	return createIntercept(parsedPublicKey, privateKey, rootCA), nil
}

// parsePublicKey parses the provided public key and returns an x509.Certificate
func parsePublicKey(newPublicKey []byte) (*x509.Certificate, error) {
	pubPem, _ := pem.Decode(newPublicKey)
	if pubPem == nil {
		return nil, ErrInvalidPublicKey
	}

	return x509.ParseCertificate(pubPem.Bytes)
}

// parsePrivateKey parses the provided private key and returns an interface{}
func parsePrivateKey(newPrivateKey []byte, password string) (interface{}, error) {
	// Decode the private key from PEM format
	privPem, _ := pem.Decode(newPrivateKey)
	if privPem == nil {
		return nil, ErrInvalidPrivateKey
	}

	// Decrypt the private key if it is encrypted
	if x509.IsEncryptedPEMBlock(privPem) {
		if privPem.Type == "ENCRYPTED PRIVATE KEY" || privPem.Type == "EC PRIVATE KEY" {
			var err error
			if privPem.Bytes, err = x509.DecryptPEMBlock(privPem, []byte(password)); err != nil {
				return nil, err
			}
		} else {
			return nil, ErrInvalidPrivateKey
		}
	}

	// Parse the private key using the PKCS#8, PKCS#1, and ECDSA formats
	privateKey, err := x509.ParsePKCS8PrivateKey(privPem.Bytes)
	if err != nil {
		privateKey, err = x509.ParsePKCS1PrivateKey(privPem.Bytes)
		if err != nil {
			privateKey, err = x509.ParseECPrivateKey(privPem.Bytes)
			if err != nil {
				return nil, err
			}
		}
	}

	return privateKey, nil
}

// parseRootCA parses the provided root CA public key and returns an x509.Certificate
func parseRootCA(newRootCAPublicKey []byte) (*x509.Certificate, error) {
	if newRootCAPublicKey == nil {
		return nil, nil
	}

	rootPem, _ := pem.Decode(newRootCAPublicKey)
	if rootPem == nil {
		return nil, ErrInvalidPublicKey
	}

	return x509.ParseCertificate(rootPem.Bytes)
}

// createIntercept creates a new Intercept object with the provided public key,
// private key, and root CA public key
func createIntercept(parsedPublicKey *x509.Certificate, privateKey interface{}, rootCA *x509.Certificate) *Intercept {
	intercept := &Intercept{
		publicKey: parsedPublicKey,
		rootCA:    rootCA,
		certStorage: certificateStorage{
			Certificates: make(map[string]IssuedCertificate),
		},
	}

	switch key := privateKey.(type) {
	case *ecdsa.PrivateKey:
		intercept.privateKeyEC = key
	case *rsa.PrivateKey:
		intercept.privateKey = key
	default:
		return nil
	}

	return intercept
}

// SetAIAAddress sets the Authority Information Access (AIA) URL for the issued certificates.
func (c *Intercept) SetAIAAddress(aiaAddress string) {
	c.aiaAddress = aiaAddress
}

// SetDomain sets the primary domain of the HTTPS server. This domain is used for SAN.
func (c *Intercept) SetDomain(domain string) {
	c.domain = domain
}

// GetCertificate fetches a certificate from certificateStorage or issues a new one
func (c *Intercept) GetCertificate(domain string) *tls.Certificate {
	c.certStorage.mutex.RLock()
	val, ok := c.certStorage.Certificates[domain]
	c.certStorage.mutex.RUnlock()

	if !ok {
		if err := c.CreateCertificate(domain); err != nil {
			log.Printf("Failed to create certificate for %s: %v", domain, err)
		}

		c.certStorage.mutex.RLock()
		val, ok = c.certStorage.Certificates[domain]
		c.certStorage.mutex.RUnlock()
		if !ok {
			log.Printf("Failed to get certificate for %s", domain)
			return nil
		}
	}

	return val.Certificate
}

// StartOperation sets OperationInProgress to true to prevent issuance flooding
func (c *certificateStorage) StartOperation(domain string) {
	c.mutex.Lock()
	defer c.mutex.Unlock()
	c.Certificates[domain] = IssuedCertificate{
		OperationInProgress: true,
	}
}

// EndOperation sets OperationInProgress to false to allow new issuance for existing domain
func (c *certificateStorage) EndOperation(domain string) {
	c.mutex.Lock()
	defer c.mutex.Unlock()
	c.Certificates[domain] = IssuedCertificate{
		OperationInProgress: false,
	}
}

// IsInOperation returns if an operation for a given domain is active
func (c *certificateStorage) IsInOperation(domain string) bool {
	c.mutex.RLock()
	defer c.mutex.RUnlock()
	return c.Certificates[domain].OperationInProgress
}

// CreateCertificate creates a new certificate for a given domain
func (c *Intercept) CreateCertificate(domain string) error {
	if c.certStorage.IsInOperation(domain) {
		log.Printf("Operation for %s is already in progress, waiting for completion", domain)
		time.Sleep(time.Second)
		return c.CreateCertificate(domain)
	}
	c.certStorage.StartOperation(domain)

	certificateCer, _ := c.generateProxyCertificate(domain)

	c.certStorage.mutex.Lock()
	defer c.certStorage.mutex.Unlock()
	c.certStorage.Certificates[domain] = IssuedCertificate{
		Certificate:         certificateCer,
		Expires:             certificateCer.Leaf.NotAfter,
		OperationInProgress: false,
	}
	log.Printf("Generated new certificate for %s", domain)

	return nil
}

// GC checks if a issued certificate is valid for less than 2 minutes and deletes it
func (c *Intercept) GC() {
	c.certStorage.mutex.Lock()
	defer c.certStorage.mutex.Unlock()

	// Count the number of certificates before
	records := len(c.certStorage.Certificates)

	// Check if any certificate is valid for less than 2 minutes. If so, delete
	// it from the certificate storage.
	for domain, cert := range c.certStorage.Certificates {
		if time.Until(cert.Expires).Minutes() <= 2 {
			log.Println("CertificateStorage GC: Removing", domain, "from generated certificates")
			delete(c.certStorage.Certificates, domain)
		}
	}

	// DEBUG: Log the number of certificates removed
	log.Printf("CertificateStorage GC: Removed %d certificates from %d", records-len(c.certStorage.Certificates), records)
}

// returnCert is called by TLS server including provided SNI name
func (c *Intercept) ReturnCert(helloInfo *tls.ClientHelloInfo) (*tls.Certificate, error) {
	domain := strings.ToLower(helloInfo.ServerName)
	// If no SNI domain was found, use certificate for dns
	if domain == "" {
		domain = "httpsintercept"
	}
	log.Println("New incoming request for", domain)

	certFromStore := c.GetCertificate(domain)
	return certFromStore, nil
}

// generateProxyCertificate generates a new certificate which is signed by an intermediate CA
func (c *Intercept) generateProxyCertificate(requestedHostname string) (*tls.Certificate, error) {
	// generate a unique and random serial number for certificate
	serialNumberLimit := new(big.Int).Lsh(big.NewInt(1), 128)
	serialNumber, err := rand.Int(rand.Reader, serialNumberLimit)
	if err != nil {
		log.Fatalf("Failed to generate serial number: %v", err)
	}

	// prefill certificate with generic fields
	template := x509.Certificate{
		SerialNumber: serialNumber,
		Subject: pkix.Name{
			CommonName: requestedHostname,
		},

		// certificate is valid from now -1 hour until now in 24 hours
		NotBefore: time.Now().Add(time.Hour * -1),
		NotAfter:  time.Now().Add(time.Hour * 24),

		KeyUsage:              x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature,
		ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth, x509.ExtKeyUsageClientAuth},
		BasicConstraintsValid: true,
	}

	// If domain is set, add AIA extension to certificate to allow clients to
	// download the intermediate certificate if missing.
	if c.aiaAddress != "" {
		template.IssuingCertificateURL = []string{c.aiaAddress}
	}

	// Also if domain is set, add main domain to SANs
	if c.domain != "" {
		// Given domain might be a IPv4 or IPv6 address. If this is the case, it needs to be added to IPAddresses
		if addr := net.ParseIP(c.domain); addr != nil {
			template.IPAddresses = append(template.IPAddresses, addr)
		} else {
			// Domain might be a domain:port combination or just a domain. Split domain and port
			domainParts := strings.Split(c.domain, ":")
			if len(domainParts) > 1 {
				template.DNSNames = append(template.DNSNames, domainParts[0])
			} else {
				template.DNSNames = append(template.DNSNames, c.domain)
			}
		}
	}

	// detect if given domain is an IP address
	// IPs do have a custom field for validation
	// if it is not an IP address, assume it is a regular domain name
	if addr := net.ParseIP(requestedHostname); addr != nil {
		template.IPAddresses = append(template.IPAddresses, addr)
	} else {
		template.DNSNames = append(template.DNSNames, requestedHostname)
	}

	// generate new private key
	key, err := genKeyPair()
	if err != nil {
		return nil, err
	}

	// Load correct private key
	var privKey any
	if c.privateKeyEC != nil {
		privKey = c.privateKeyEC
	} else {
		privKey = c.privateKey
	}

	// issue certificate
	x, err := x509.CreateCertificate(rand.Reader, &template, c.publicKey, key.Public(), privKey)
	if err != nil {
		return nil, err
	}

	// create certificate container including new certificate, private key and chain
	cert := new(tls.Certificate)
	cert.Certificate = append(cert.Certificate, x)
	cert.PrivateKey = key
	cert.Leaf, _ = x509.ParseCertificate(x)

	// add intermediate certificate to chain
	cert.Certificate = append(cert.Certificate, c.publicKey.Raw)
	cert.Leaf.Issuer = c.publicKey.Subject

	// add root certificate to chain
	if c.rootCA != nil {
		cert.Certificate = append(cert.Certificate, c.rootCA.Raw)
	}

	return cert, nil
}

// genKeyPair generates a new private key
func genKeyPair() (*ecdsa.PrivateKey, error) {
	return ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
}

// GenerateCRL generates a Certificate Revocation List (CRL) for the issued
// certificates. This list will always be empty.
func (c *Intercept) GenerateCRL(crlAddress, path string) error {
	// Prepare empty revoked certificates list
	revoked := []pkix.RevokedCertificate{}

	now := time.Now()
	nextUpdate := now.AddDate(0, 0, 8)

	crlBytes, err := x509.CreateRevocationList(rand.Reader, &x509.RevocationList{
		SignatureAlgorithm:  c.publicKey.SignatureAlgorithm,
		Issuer:              c.publicKey.Subject,
		ThisUpdate:          now,
		NextUpdate:          nextUpdate,
		RevokedCertificates: revoked,
		Number:              big.NewInt(now.Unix()),
	}, c.publicKey, c.privateKey)
	if err != nil {
		return err
	}

	file, err := os.Create(path)
	if err != nil {
		return err
	}
	defer file.Close()

	// Store the file in DER format
	if _, err := file.Write(crlBytes); err != nil {
		return err
	}

	return nil
}
