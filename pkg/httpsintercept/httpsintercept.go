package httpsintercept

import (
	"crypto"
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rand"
	"crypto/rsa"
	"crypto/tls"
	"crypto/x509"
	"crypto/x509/pkix"
	"encoding/asn1"
	"encoding/pem"
	"errors"
	"log"
	"math/big"
	"net"
	"os"
	"slices"
	"strings"
	"sync"
	"time"
)

type Intercept struct {
	publicKey    *x509.Certificate // Public key of the Intermediate CA or Root CA used to sign the fake certificates
	privateKey   *rsa.PrivateKey   // Private key of the Intermediate CA or Root CA used to sign the fake certificates
	privateKeyEC *ecdsa.PrivateKey // Private key of the Intermediate CA or Root CA used to sign the fake certificates
	rootCA       *x509.Certificate // Root CA certificate to complete the chain of trust
	domain       string            // Primary domain of the HTTPS server. Used for SAN
	aiaAddress   string            // Authority Information Access (AIA) URL for the issued certificates
	crlAddress   string            // CRL Distribution Point URL for the issued certificates

	// certificateStorage contains all issued certificates including rw lock
	certStorage certificateStorage
}

// certificateStorage contains all issued certificates including rw lock
type certificateStorage struct {
	mutex        sync.RWMutex
	Certificates map[string]IssuedCertificate
}

// IssuedCertificate contains a single issued certificate
type IssuedCertificate struct {
	Certificate         *tls.Certificate `json:"certificate"`
	Expires             time.Time        `json:"expires"`
	OperationInProgress bool             `json:"operation_in_progress"`
}

var (
	ErrInvalidPublicKey  = errors.New("invalid public key")
	ErrInvalidPrivateKey = errors.New("invalid private key")
	ErrRootCANotProvided = errors.New("root ca not provided")
)

// New creates a new Intercept object with the provided public key, private key,
// and root CA public key. The public key and private key are used to sign the
// fake certificates generated by the MITM proxy. The root CA public key is used
// to complete the chain of trust when generating the fake certificates.
func New(newPublicKey, newPrivateKey []byte, password string, newRootCAPublicKey []byte) (*Intercept, error) {
	parsedPublicKey, err := parsePublicKey(newPublicKey)
	if err != nil {
		return nil, err
	}

	privateKey, err := parsePrivateKey(newPrivateKey, password)
	if err != nil {
		return nil, err
	}

	rootCA, err := parseRootCA(newRootCAPublicKey)
	if err != nil && !errors.Is(err, ErrRootCANotProvided) {
		return nil, err
	}
	if errors.Is(err, ErrRootCANotProvided) {
		rootCA = nil
	}

	return createIntercept(parsedPublicKey, privateKey, rootCA)
}

// parsePublicKey parses the provided public key and returns an x509.Certificate
func parsePublicKey(newPublicKey []byte) (*x509.Certificate, error) {
	pubPem, _ := pem.Decode(newPublicKey)
	if pubPem == nil {
		return nil, ErrInvalidPublicKey
	}

	return x509.ParseCertificate(pubPem.Bytes)
}

// parsePrivateKey parses the provided private key and returns an interface{}
func parsePrivateKey(newPrivateKey []byte, password string) (any, error) {
	// Decode the private key from PEM format
	privPem, _ := pem.Decode(newPrivateKey)
	if privPem == nil {
		return nil, ErrInvalidPrivateKey
	}

	// Decrypt the private key if it is encrypted
	if x509.IsEncryptedPEMBlock(privPem) { //nolint:staticcheck // needed for legacy encrypted PEM key support
		if privPem.Type == "ENCRYPTED PRIVATE KEY" || privPem.Type == "EC PRIVATE KEY" {
			var err error
			if privPem.Bytes, err = x509.DecryptPEMBlock(privPem, []byte(password)); err != nil { //nolint:staticcheck // needed for legacy encrypted PEM key support
				return nil, err
			}
		} else {
			return nil, ErrInvalidPrivateKey
		}
	}

	// Parse the private key using the PKCS#8, PKCS#1, and ECDSA formats
	privateKey, err := x509.ParsePKCS8PrivateKey(privPem.Bytes)
	if err != nil {
		privateKey, err = x509.ParsePKCS1PrivateKey(privPem.Bytes)
		if err != nil {
			privateKey, err = x509.ParseECPrivateKey(privPem.Bytes)
			if err != nil {
				return nil, err
			}
		}
	}

	return privateKey, nil
}

// parseRootCA parses the provided root CA public key and returns an x509.Certificate
func parseRootCA(newRootCAPublicKey []byte) (*x509.Certificate, error) {
	if len(newRootCAPublicKey) == 0 {
		return nil, ErrRootCANotProvided
	}

	rootPem, _ := pem.Decode(newRootCAPublicKey)
	if rootPem == nil {
		return nil, ErrInvalidPublicKey
	}

	return x509.ParseCertificate(rootPem.Bytes)
}

// createIntercept creates a new Intercept object with the provided public key,
// private key, and root CA public key
func createIntercept(parsedPublicKey *x509.Certificate, privateKey any, rootCA *x509.Certificate) (*Intercept, error) {
	intercept := &Intercept{
		publicKey: parsedPublicKey,
		rootCA:    rootCA,
		certStorage: certificateStorage{
			Certificates: make(map[string]IssuedCertificate),
		},
	}

	switch key := privateKey.(type) {
	case *ecdsa.PrivateKey:
		intercept.privateKeyEC = key
	case *rsa.PrivateKey:
		intercept.privateKey = key
	default:
		return nil, errors.New("invalid private key type")
	}

	return intercept, nil
}

// SetAIAAddress sets the Authority Information Access (AIA) URL for the issued
// certificates.
func (c *Intercept) SetAIAAddress(aiaAddress string) {
	c.aiaAddress = aiaAddress
}

// SetDomain sets the primary domain of the HTTPS server. This domain is used
// for SAN.
func (c *Intercept) SetDomain(domain string) {
	c.domain = domain
}

// SetCRLAddress sets the CRL Distribution Point URL for the issued
// certificates.
func (c *Intercept) SetCRLAddress(crlAddress string) {
	c.crlAddress = crlAddress
}

// GetCertificate fetches a certificate from certificateStorage or issues a new one
func (c *Intercept) GetCertificate(domain string) *tls.Certificate {
	c.certStorage.mutex.RLock()
	val, ok := c.certStorage.Certificates[domain]
	c.certStorage.mutex.RUnlock()

	if !ok {
		if err := c.CreateCertificate(domain); err != nil {
			log.Printf("Failed to create certificate for %s: %v", domain, err)
		}

		c.certStorage.mutex.RLock()
		val, ok = c.certStorage.Certificates[domain]
		c.certStorage.mutex.RUnlock()
		if !ok {
			log.Printf("Failed to get certificate for %s", domain)
			return nil
		}
	}

	return val.Certificate
}

// StartOperation sets OperationInProgress to true to prevent issuance flooding
func (c *certificateStorage) StartOperation(domain string) {
	c.mutex.Lock()
	defer c.mutex.Unlock()
	cert := c.Certificates[domain]
	cert.OperationInProgress = true
	c.Certificates[domain] = cert
}

// EndOperation sets OperationInProgress to false to allow new issuance for existing domain
func (c *certificateStorage) EndOperation(domain string) {
	c.mutex.Lock()
	defer c.mutex.Unlock()
	cert := c.Certificates[domain]
	cert.OperationInProgress = false
	c.Certificates[domain] = cert
}

// IsInOperation returns if an operation for a given domain is active
func (c *certificateStorage) IsInOperation(domain string) bool {
	c.mutex.RLock()
	defer c.mutex.RUnlock()
	return c.Certificates[domain].OperationInProgress
}

// CreateCertificate creates a new certificate for a given domain
func (c *Intercept) CreateCertificate(domain string) error {
	if c.certStorage.IsInOperation(domain) {
		log.Printf("Operation for %s is already in progress, waiting for completion", domain)
		time.Sleep(time.Second)
		return c.CreateCertificate(domain)
	}
	c.certStorage.StartOperation(domain)

	certificateCer, err := c.generateProxyCertificate(domain)
	if err != nil {
		c.certStorage.EndOperation(domain)
		return err
	}

	c.certStorage.mutex.Lock()
	c.certStorage.Certificates[domain] = IssuedCertificate{
		Certificate:         certificateCer,
		Expires:             certificateCer.Leaf.NotAfter,
		OperationInProgress: false,
	}
	c.certStorage.mutex.Unlock()
	log.Printf("Generated new certificate for %s", domain)

	return nil
}

// GC removes expired and nearly expired certificates from the storage
func (c *Intercept) GC() {
	c.certStorage.mutex.Lock()
	defer c.certStorage.mutex.Unlock()

	var toDelete []string
	for domain, cert := range c.certStorage.Certificates {
		if time.Until(cert.Expires) <= 2*time.Minute {
			toDelete = append(toDelete, domain)
		}
	}
	for _, domain := range toDelete {
		log.Println("CertificateStorage GC: Removing", domain, "from generated certificates")
		delete(c.certStorage.Certificates, domain)
	}
	log.Printf("CertificateStorage GC: Removed %d certificates, %d remain", len(toDelete), len(c.certStorage.Certificates))
}

// ReturnCert is called by TLS server including provided SNI name
func (c *Intercept) ReturnCert(helloInfo *tls.ClientHelloInfo) (*tls.Certificate, error) {
	domain := strings.ToLower(helloInfo.ServerName)
	// If no SNI domain was found, try to get the IP from the connection
	if domain == "" {
		if conn := helloInfo.Conn; conn != nil {
			if localAddr, ok := conn.LocalAddr().(*net.TCPAddr); ok {
				domain = localAddr.IP.String()
			}
		}
	}
	// If still no domain found, use certificate for configured domain
	if domain == "" {
		domain = c.domain
	}
	log.Println("New incoming request for", domain)

	certFromStore := c.GetCertificate(domain)
	return certFromStore, nil
}

// generateProxyCertificate generates a new certificate which is signed by an intermediate CA
func (c *Intercept) generateProxyCertificate(requestedHostname string) (*tls.Certificate, error) {
	template, err := c.newProxyCertificateTemplate(requestedHostname)
	if err != nil {
		return nil, err
	}

	key, err := genKeyPair()
	if err != nil {
		return nil, err
	}

	x, err := x509.CreateCertificate(rand.Reader, &template, c.publicKey, key.Public(), c.signingPrivateKey())
	if err != nil {
		return nil, err
	}

	return c.buildTLSCertificate(x, key)
}

func newCertificateSerialNumber() (*big.Int, error) {
	serialNumberLimit := new(big.Int).Lsh(big.NewInt(1), 128)
	serialNumber, err := rand.Int(rand.Reader, serialNumberLimit)
	if err != nil {
		log.Printf("Failed to generate serial number: %v", err)
		return nil, err
	}
	return serialNumber, nil
}

func (c *Intercept) newProxyCertificateTemplate(requestedHostname string) (x509.Certificate, error) {
	serialNumber, err := newCertificateSerialNumber()
	if err != nil {
		return x509.Certificate{}, err
	}
	now := time.Now()

	template := x509.Certificate{
		SerialNumber: serialNumber,
		Subject: pkix.Name{
			CommonName: requestedHostname,
		},
		NotBefore: now.Add(-1 * time.Hour),
		NotAfter:  now.Add(24 * time.Hour),
		KeyUsage:  x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature,
		ExtKeyUsage: []x509.ExtKeyUsage{
			x509.ExtKeyUsageServerAuth,
			x509.ExtKeyUsageClientAuth,
		},
		BasicConstraintsValid: true,
	}

	if c.aiaAddress != "" {
		template.IssuingCertificateURL = []string{c.aiaAddress}
	}
	if c.crlAddress != "" {
		template.CRLDistributionPoints = []string{c.crlAddress}
	}

	// Requested host and configured fallback domain are both valid SAN candidates.
	addSANEntry(&template, requestedHostname)
	addSANEntry(&template, normalizeSANHost(c.domain))

	return template, nil
}

func addSANEntry(template *x509.Certificate, host string) {
	if host == "" {
		return
	}
	// Route SAN insertion by host type so DNS/IP entries stay type-correct.
	if ip := net.ParseIP(host); ip != nil {
		appendUniqueIP(template, ip)
		return
	}
	appendUniqueDNS(template, host)
}

func appendUniqueIP(template *x509.Certificate, ip net.IP) {
	// net.IP requires semantic equality checks (not byte-slice pointer equality).
	for _, existing := range template.IPAddresses {
		if existing.Equal(ip) {
			return
		}
	}
	template.IPAddresses = append(template.IPAddresses, ip)
}

func appendUniqueDNS(template *x509.Certificate, dnsName string) {
	if !slices.Contains(template.DNSNames, dnsName) {
		template.DNSNames = append(template.DNSNames, dnsName)
	}
}

func normalizeSANHost(host string) string {
	if host == "" {
		return ""
	}

	trimmedHost := strings.TrimSpace(host)
	if parsedHost, _, err := net.SplitHostPort(trimmedHost); err == nil {
		trimmedHost = parsedHost
	}

	// x509 SAN entries require the raw host value without bracket notation.
	trimmedHost = strings.TrimPrefix(trimmedHost, "[")
	trimmedHost = strings.TrimSuffix(trimmedHost, "]")

	return trimmedHost
}

func (c *Intercept) signingPrivateKey() any {
	if c.privateKeyEC != nil {
		return c.privateKeyEC
	}
	return c.privateKey
}

func (c *Intercept) buildTLSCertificate(leafCertDER []byte, key *ecdsa.PrivateKey) (*tls.Certificate, error) {
	cert := &tls.Certificate{
		Certificate: [][]byte{leafCertDER},
		PrivateKey:  key,
	}
	leaf, err := x509.ParseCertificate(leafCertDER)
	if err != nil {
		return nil, err
	}
	cert.Leaf = leaf

	// Keep the leaf+intermediate(+optional root) order expected by TLS clients.
	cert.Certificate = append(cert.Certificate, c.publicKey.Raw)
	cert.Leaf.Issuer = c.publicKey.Subject

	if c.rootCA != nil {
		cert.Certificate = append(cert.Certificate, c.rootCA.Raw)
	}

	return cert, nil
}

// genKeyPair generates a new private key
func genKeyPair() (*ecdsa.PrivateKey, error) {
	return ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
}

// GenerateCRL generates a Certificate Revocation List (CRL) for the issued
// certificates. This list will always be empty.
func (c *Intercept) GenerateCRL(crlAddress, path string) error {
	// Prepare empty revoked certificates list
	revoked := []pkix.RevokedCertificate{}

	now := time.Now()
	nextUpdate := now.AddDate(0, 0, 15) // Next update in 15 days

	var priv crypto.Signer
	if c.privateKeyEC != nil {
		priv = c.privateKeyEC
	} else {
		priv = c.privateKey
	}

	var idpExt pkix.Extension
	if crlAddress != "" {
		var err error
		idpExt, err = issuingDistributionPointExtension(
			crlAddress,
			true,  // onlyContainsUserCerts
			false, // onlyContainsCACerts
			false, // indirectCRL
		)
		if err != nil {
			return err
		}
	}

	crlBytes, err := x509.CreateRevocationList(rand.Reader, &x509.RevocationList{
		SignatureAlgorithm:  0,
		Issuer:              c.publicKey.Subject,
		ThisUpdate:          now.UTC(),
		NextUpdate:          nextUpdate.UTC(),
		RevokedCertificates: revoked,
		Number:              big.NewInt(now.Unix()),
		ExtraExtensions: []pkix.Extension{
			idpExt,
		},
	}, c.publicKey, priv)
	if err != nil {
		return err
	}

	file, err := os.Create(path)
	if err != nil {
		return err
	}
	defer file.Close()

	// Store the file in DER format
	if _, err := file.Write(crlBytes); err != nil {
		return err
	}

	return nil
}

func derLen(n int) []byte {
	if n < 0x80 {
		return []byte{byte(n)}
	}
	// long form
	tmp := make([]byte, 0, 4)
	for x := n; x > 0; x >>= 8 {
		tmp = append([]byte{byte(x & 0xff)}, tmp...)
	}
	return append([]byte{0x80 | byte(len(tmp))}, tmp...)
}

func derTLV(tag byte, content []byte) []byte {
	out := make([]byte, 0, 1+5+len(content))
	out = append(out, tag)
	out = append(out, derLen(len(content))...)
	out = append(out, content...)
	return out
}

// buildIssuingDistributionPoint builds OID 2.5.29.28 value
func buildIssuingDistributionPoint(uri string, onlyUser, onlyCA, indirect bool) ([]byte, error) {
	if onlyUser && onlyCA {
		return nil, errors.New("onlyUser and onlyCA cannot both be true")
	}
	// URI in GeneralName is IA5String -> ASCII
	for i := 0; i < len(uri); i++ {
		if uri[i] > 0x7f {
			return nil, errors.New("uri must be ASCII (IA5String)")
		}
	}

	// GeneralName uniformResourceIdentifier [6] IA5String
	gnURI := derTLV(0x86, []byte(uri))

	// DistributionPointName CHOICE fullName [0] GeneralNames
	// fullName [0] wrapping the GeneralName list/content
	fullName := derTLV(0xA0, gnURI)

	// IssuingDistributionPoint.distributionPoint [0] DistributionPointName
	dp := derTLV(0xA0, fullName)

	body := make([]byte, 0, len(dp)+9)
	body = append(body, dp...)

	// [1] onlyContainsUserCerts BOOLEAN TRUE
	if onlyUser {
		body = append(body, 0x81, 0x01, 0xFF)
	}
	// [2] onlyContainsCACerts BOOLEAN TRUE
	if onlyCA {
		body = append(body, 0x82, 0x01, 0xFF)
	}
	// [4] indirectCRL BOOLEAN TRUE
	if indirect {
		body = append(body, 0x84, 0x01, 0xFF)
	}

	// SEQUENCE
	return derTLV(0x30, body), nil
}

func issuingDistributionPointExtension(uri string, onlyUser, onlyCA, indirect bool) (pkix.Extension, error) {
	val, err := buildIssuingDistributionPoint(uri, onlyUser, onlyCA, indirect)
	if err != nil {
		return pkix.Extension{}, err
	}
	return pkix.Extension{
		Id:       asn1.ObjectIdentifier{2, 5, 29, 28}, // issuingDistributionPoint
		Critical: true,
		Value:    val,
	}, nil
}
